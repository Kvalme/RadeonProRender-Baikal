#version 450

#define TILE_SIZE 8

#include "common.glsl"
#include "utils.glsl"

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout (binding = 0) uniform sampler2D spheremap;
layout (binding = 1, rgba16f) uniform writeonly imageCube cubemap;

layout(push_constant) uniform PushConsts
{
    float ibl_multiplier;
} push_constants;

vec3 MapXYSToDirection(uint x, uint y, uint s, int width, int height)
{
    const float u = ((x + 0.5f) / float(width)) * 2.0f - 1.0f;
    const float v = ((y + 0.5f) / float(height)) * 2.0f - 1.0f;

    vec3 dir = vec3(0.0f);

    const bool invert_x = false;
    const vec3 x_dir = invert_x ? vec3(-1.f, 1.f, 1.f) : vec3(1.f, 1.f, 1.f);

    switch(s) {
    case 0:
        dir = normalize(x_dir * vec3(-1.0f, v, -u));
        break;
    case 1:
        dir = normalize(x_dir * vec3(1.0f, v, u));
        break;
    case 2:
        dir = normalize(x_dir * vec3(-u, -1.0f, v));
        break;
    case 3:
        dir = normalize(x_dir * vec3(-u, 1.0f, v));
        break;
    case 4:
        dir = normalize(x_dir * vec3(-u, v, 1.0f));
        break;
    case 5:
        dir = normalize(x_dir * vec3(u, v, -1.0f));
        break;
    }

    return dir;
}

void main() 
{
    ivec2 size = imageSize(cubemap);
    float ibl_multiplier = push_constants.ibl_multiplier;
    int num_pixels = size.x * size.y;

    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const uint face = gl_GlobalInvocationID.z;

    if (x >= size.x || y >= size.y)
        return;

    vec3 dir = MapXYSToDirection(x, y, face, size.x, size.y);

    // convert dir to uv
    vec3 sp = CartesianToSpherical(dir);
	vec2 st = vec2(sp.y / (2 * PI), 1.0f - sp.z / PI);
    vec4 v = textureLod(spheremap, st, 0.0f) * ibl_multiplier;

    imageStore(cubemap, ivec3(x, y, face), v);
}